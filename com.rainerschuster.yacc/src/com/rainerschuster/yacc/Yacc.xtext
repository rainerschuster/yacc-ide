grammar com.rainerschuster.yacc.Yacc //with org.eclipse.xtext.common.Terminals
 hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate yacc "http://www.rainerschuster.com/yacc/Yacc"

Specification:
	{Specification} definitions+=Definition* ('%%'|'\\\\') rules+=Rule* tail=Tail?
;

Tail:
	// After the delimiter any token should be matched until the end of file
	('%%'|'\\\\') (LITERAL|BLOCK|CODE|ID|INT|STRING|ML_COMMENT|SL_COMMENT|WS|ANY_OTHER|','|'%%'|'\\\\'|'<'|'>'|':'|'|'|';'|'=')*
;

Definition:
	StartDefinition
	| UnionDefinition
	| CodeDefinition
	| RWordDefinition

	| DestructorDefinition
	| ExpectDefinition
	| ExpectRrDefinition
	| IdentDefinition
	| LocationsDefinition
	| LexParamDefinition
	| ParseParamDefinition
//	| PrecedenceDefinition
	| PureParserDefinition
	| TokenTableDefinition
;

StartDefinition:
	'%start' start=[Rule|ID]
;

UnionDefinition:
	'%union' assignment?='='? union=BLOCK semi?=';'?
;

RWordDefinition:
	/*definitions+=Def**/ rword=RWord tag=Tag? nlist+=Nmno (','? nlist+=Nmno)*
;

DestructorDefinition:
	'%destructor' code=BLOCK references+=ReferenceOrLiteral+
;

ExpectDefinition:
	'%expect' number=INT
;

ExpectRrDefinition:
	'%expect-rr' number=INT
;

// TODO Where is this defined?
IdentDefinition:
	('%ident'
	| '%IDENT')
		ident=STRING
;

LocationsDefinition:
	{LocationsDefinition} ('%locations'
	| '%LOCATIONS') // TODO is this valid?
;

LexParamDefinition:
	('%lex-param'
	| '%lex_param' // TODO is this valid?
	| '%LEX_PARAM') // TODO is this valid?
		argumentDeclarations=BLOCK
;

ParseParamDefinition:
	('%parse-param'
	| '%parse_param' // TODO is this valid?
	| '%PARSE_PARAM') // TODO is this valid?
		argumentDeclarations=BLOCK
;

PureParserDefinition:
	{PureParserDefinition} ('%pure-parser'
	| '%pure_parser' // TODO is this valid?
	| '%PURE_PARSER') // TODO is this valid?
;

TokenTableDefinition:
	{TokenTableDefinition} '%token-table'
;

CodeDefinition:
	code=CODE
;

//RWord:
//	'%' ID
//;
enum RWord:
	TOKEN='%token'
	| LEFT='%left' | LEFT='%<'
	| RIGHT='%right' | RIGHT='%>'
	| NONASSOC='%nonassoc'
	| TYPE='%type'
;

Tag:
	'<' Identifier '>'
;

Nmno:
	name=Identifier number=INT? string=STRING?
;

Rule:
	name=ID ':' alternatives+=RuleBody ('|' alternatives+=RuleBody)*
;

RuleBody:
	{RuleBody} rbody+=RuleBodyElement* precedence=Precedence?
;

RuleBodyElement:
	{RuleError}'error'
	| {RuleReference}ref=ReferenceOrLiteral
	| Action
;

Action:
	action=BLOCK
;

Precedence:
	{Precedence} ('%prec' ref=ReferenceOrLiteral action=Action?) semi?=';'?
	| {Precedence} semi?=';'
;

NamedElement:
	Rule
	| Nmno
;

ReferenceOrLiteral:
	ref=[NamedElement|ID]
	| literal=LITERAL
	| string=STRING
;

Identifier:
	ID | LITERAL
;

// TODO validate: Only numbers may have more than one character!
terminal LITERAL:
	"'" ( '\\' .+ | !('\\'|"'") ) "'"
;

//terminal BLOCK	: '{' -> '}';
terminal BLOCK	: '{' (BLOCK|!('{'|'}'))* '}'; // TODO "*" or "*?"?
terminal CODE	: '%{' -> '%}';


terminal ID  		: ('a'..'z'|'A'..'Z'|'_'|'.') ('a'..'z'|'A'..'Z'|'_'|'.'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING	:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"'
		;
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

//terminal TAIL:
//	'%%' (!'%%')* EOF
//;

terminal ANY_OTHER: .;
