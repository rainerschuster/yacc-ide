grammar com.rainerschuster.yacc.Yacc //with org.eclipse.xtext.common.Terminals
 hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate yacc "http://www.rainerschuster.com/yacc/Yacc"

Specification:
	{Specification} definitions+=Definition* ('%%'|'\\\\') body+=RuleOrDefinition* tail=Tail?
;

Tail:
	// After the delimiter any token should be matched until the end of file
	('%%'|'\\\\') (LITERAL|BLOCK|CODE|ID|INT|STRING|ML_COMMENT|SL_COMMENT|WS|ANY_OTHER|','|'%%'|'\\\\'|'<'|'>'|':'|'|'|';'|'='|'*')*
;


Definition:
	(
// grammar declarations:
	StartDefinition
	| UnionDefinition
	| CodeDefinition
	| RWordDefinition
	| TypeDefinition

	| BisonCodeDefinition
	| BisonDefaultPrecDefinition
	| BisonNoDefaultPrecDefinition

// prologue declarations:
//	| CodeDefinition
// TODO %<flag>
	| BisonDefineDefinition
	| BisonDefinesDefinition
	| BisonErrorVerboseDefinition
	| ExpectDefinition
	| ExpectRrDefinition
	| BisonFilePrefixDefinition
	| BisonGlrParserDefinition
	| BisonInitialActionDefinition
	| BisonLanguageDefinition
	| BisonNamePrefixDefinition
	| BisonNoLinesDefinition
	| BisonNondeterministicParserDefinition
	| BisonOutputDefinition
	| BisonParamDefinition
	| BisonPrinterDefinition
	| BisonRequireDefinition
	| BisonSkeletonDefinition
	| TokenTableDefinition
	| BisonVerboseDefinition
	| BisonYaccDefinition
	| DestructorDefinition
	| IdentDefinition
	| LocationsDefinition
	| LexParamDefinition
	| ParseParamDefinition
//	| PrecedenceDefinition
	| PureParserDefinition)';'?
;

StartDefinition:
	'%start' start=[Rule|ID] // TODO Symbol instead of ID
;

UnionDefinition:
	'%union' assignment?='='? union=BLOCK
;

RWordDefinition:
	/*definitions+=Def**/ rword=RWord tag=Tag? nlist+=Nmno (','? nlist+=Nmno)*
;

TypeDefinition:
	'%type' tag=Tag? symbols+=Symbol+
;

enum BisonCodeTop:
	TOP='top'
	| REQUIRES='requires'
	| PROVIDES='provides'
;

BisonCodeDefinition:
	'%code' x=BisonCodeTop? code=BLOCK
;

BisonDefaultPrecDefinition:
	{BisonDefaultPrecDefinition} '%default-prec'
;

BisonDefineDefinition:
	'%define' variable=Variable value=Value?
;

// TODO Bison helper
Symbol:
	id=ID
//	| literal=LITERAL
	| string=STRING
;

// TODO Bison helper
SymbolWithPrecedence:
	symbol=Symbol precedence=INT?
;

// TODO Bison helper
// TODO this should be a reference
GenericSymbol:
	Symbol
	| {TagSymbol} tag=Tag
;

// TODO Bison helper
Variable:
	id=ID
	| literal=LITERAL
	| string=STRING
;

// TODO Bison helper
Value:
	id=ID
	| literal=LITERAL
	| string=STRING
//	| ReferenceOrLiteral
	| code=BLOCK
;

BisonDefinesDefinition:
	{BisonDefinesDefinition}'%defines' defines=STRING?
;

BisonErrorVerboseDefinition:
	{BisonErrorVerboseDefinition}'%error-verbose'
;

ExpectDefinition:
	'%expect' number=INT
;

ExpectRrDefinition:
	'%expect-rr' number=INT
;

BisonFilePrefixDefinition:
	'%file-prefix' prefix=STRING
;

BisonGlrParserDefinition:
	{BisonGlrParserDefinition}'%glr-parser'
;

BisonInitialActionDefinition:
	'%initial-action' action=BLOCK
;

BisonLanguageDefinition:
	'%language' language=STRING
;

BisonNamePrefixDefinition:
	'%name-prefix' language=STRING
;

BisonNoDefaultPrecDefinition:
	{BisonNoDefaultPrecDefinition} '%no-default-prec'
;

BisonNoLinesDefinition:
	{BisonNoLinesDefinition} '%no-lines'
;

BisonNondeterministicParserDefinition:
	{BisonNondeterministicParserDefinition} '%nondeterministic-parser'
;

BisonOutputDefinition:
	'%output' output=STRING
;

BisonParamDefinition:
	'%param' argumentDeclarations+=BLOCK+
;

BisonPrinterDefinition:
	'%printer' code=BLOCK symbols+=GenericSymbol+
;

BisonRequireDefinition:
	'%require' require=STRING
;

BisonSkeletonDefinition:
	'%skeleton' skeleton=STRING
;

TokenTableDefinition:
	{TokenTableDefinition} '%token-table'
;

BisonVerboseDefinition:
	{BisonVerboseDefinition}'%verbose'
;

BisonYaccDefinition:
	{BisonYaccDefinition}'%yacc'
;

DestructorDefinition:
	'%destructor' code=BLOCK symbols+=GenericSymbol+
;

// TODO Where is this defined?
IdentDefinition:
	('%ident'
	| '%IDENT')
		ident=STRING
;

LocationsDefinition:
	{LocationsDefinition} ('%locations'
	| '%LOCATIONS') // TODO is this valid?
;

LexParamDefinition:
	('%lex-param'
	| '%lex_param' // TODO is this valid?
	| '%LEX_PARAM') // TODO is this valid?
		argumentDeclarations+=BLOCK+
;

ParseParamDefinition:
	('%parse-param'
	| '%parse_param' // TODO is this valid?
	| '%PARSE_PARAM') // TODO is this valid?
		argumentDeclarations+=BLOCK+
;

PureParserDefinition:
	{PureParserDefinition} ('%pure-parser'
	| '%pure_parser' // TODO is this valid?
	| '%PURE_PARSER') // TODO is this valid?
;

CodeDefinition:
	code=CODE
;

//RWord:
//	'%' ID
//;
enum RWord:
	TOKEN='%token'
	| LEFT='%left' | LEFT='%<'
	| RIGHT='%right' | RIGHT='%>'
	| NONASSOC='%nonassoc'
//	| TYPE='%type'
;

Tag:
	'<' Identifier '>'
	| '<' '*' '>' // default tagged
	| '<' '>' // default tagless
;

Nmno:
	name=Identifier number=INT? string=STRING?
//	| name=Tag
;

RuleOrDefinition:
	Rule
	| Definition
;

Rule:
	name=ID ':' alternatives+=RuleBody ('|' alternatives+=RuleBody)*
;

RuleBody:
	{RuleBody} rbody+=RuleBodyElement* precedence=Precedence?
;

RuleBodyElement:
	{RuleError}'error'
	| {RuleEmpty}'%empty'
	| {RuleReference}ref=ReferenceOrLiteral
	| Action
;

Action:
	action=BLOCK
;

Precedence:
	{Precedence} ('%prec' ref=ReferenceOrLiteral action=Action?) semi?=';'?
	| {Precedence} semi?=';'
;

NamedElement:
	Rule
	| Nmno
;

ReferenceOrLiteral:
	ref=[NamedElement|ID]
	| literal=LITERAL
	| string=STRING
;

Identifier:
	ID | LITERAL
;

// TODO validate: Only numbers may have more than one character!
terminal LITERAL:
	"'" ( '\\' .+ | !('\\'|"'") ) "'"
;

//terminal BLOCK	: '{' -> '}';
terminal BLOCK	: '{' (BLOCK|!('{'|'}'))* '}'; // TODO "*" or "*?"?
terminal CODE	: '%{' -> '%}';


terminal ID  		: ('a'..'z'|'A'..'Z'|'_'|'.') ('a'..'z'|'A'..'Z'|'_'|'.'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING	:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"'
		;
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

//terminal TAIL:
//	'%%' (!'%%')* EOF
//;

terminal ANY_OTHER: .;
